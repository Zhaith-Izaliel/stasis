{ package }:
{
  config,
  lib,
  ...
}:

let
  inherit (lib)
    mkEnableOption
    mkPackageOption
    mkIf
    getExe
    mkOption
    types
    escapeShellArgs
    optional
    optionals
    literalExpression
    ;

  cfg = config.services.stasis;

  defaultArgs = optionals (cfg.extraConfig != null) [
    "-c"
    "/etc/stasis/stasis.rune"
  ];
in
{
  options = {
    services.stasis = {
      enable = mkEnableOption "Stasis, a lightweight, feature rich Wayland idle manager written in Rust";

      package = mkPackageOption { stasis = package; } "stasis" { };

      extraConfig = mkOption {
        type = types.nullOr types.lines;
        default = null;
        description = ''
          The literal contents of the Stasis configuration file.

          If set, Nix will write this text to
          `/etc/stasis/config.rune`.
        '';
        example = literalExpression ''
          # This file was auto-generated by Stasis on first run
          # Feel free to customize it to your needs
          # Master config reference: `/usr/share/doc/stasis/stasis.rune`

          @author "Dustin Pilgrim"
          @description "Lightweight feature packed idle manager for Wayland"

          # IMPORTANT (new semantics):
          # - Everything lives under `default:` (and optional profile blocks).
          # - On laptops, Stasis chooses between:
          #     `default.ac:` and `default.battery:`
          #   depending on current power source.

          active_profile null

          default:
            # Optional: run before suspending (e.g., ensure lock is up)
            #pre_suspend_command "swaylock"

            monitor_media true
            ignore_remote_media true # ignore remote players (spotify/kdeconnect/etc.)

            # Optional: ignore these media sources for media inhibit (case-insensitive)
            #media_blacklist ["spotify"]

            # Debounce window in seconds before starting the plan (default 0)
            #debounce_seconds 4

            # Notify when resuming from IPC pause (e.g., `stasis pause 1h`)
            #notify_on_unpause true

            # Global gate: notifications before steps only happen if this is true
            #notify_before_action true

            # App/process inhibit patterns (strings or regex literals)
            inhibit_apps [
              "vlc"
              "mpv"
              r"steam_app_.*"
            ]

            # Laptop plan: AC power (relaxed)
            ac:
              brightness:
                timeout 300 # 5 minute(s)
                command "brightnessctl set 50%"
              end

              dpms:
                timeout 120 # 2 minute(s) after brightness
                command "niri msg action power-off-monitors"
                resume_command "niri msg action power-on-monitors"
              end

              lock_screen:
                timeout 180 # 3 minute(s) after dpms
                command "swaylock"

                # Optional per-step notification:
                #notification "Locking session soon"
                #notify_seconds_before 10
              end

              suspend:
                timeout 600 # 10 minute(s) after lock
                command "systemctl suspend"
              end
            end

            # Laptop plan: Battery power (aggressive)
            battery:
              brightness:
                timeout 60 # 1 minute(s)
                command "brightnessctl set 30%"
              end

              dpms:
                timeout 30 # 30 second(s) after brightness
                command "niri msg action power-off-monitors"
                resume_command "niri msg action power-on-monitors"
              end

              lock_screen:
                timeout 60 # 1 minute(s) after dpms
                command "swaylock"

                # Optional loginctl integration for lock step only:
                #use_loginctl true
              end

              suspend:
                timeout 120 # 2 minute(s) after lock
                command "systemctl suspend"
              end
            end
          end
        '';
      };

      target = mkOption {
        type = types.nonEmptyStr;
        default = "graphical-session.target";
        description = "The systemd user target after which Stasis is started.";
      };

      extraArgs = mkOption {
        type = types.listOf types.str;
        default = defaultArgs;
        defaultText = literalExpression ''
          if services.stasis.extraConfig != null then
          [
             "-c"
             "/etc/stasis/stasis.rune"
          ] else []
        '';
        description = ''
          Extra arguments to pass to Stasis.

          The default arguments from this module will be **ignored**.
        '';
      };
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [
      cfg.package
    ];

    systemd.user.services."stasis" = {
      description = "Stasis Wayland Idle Manager";
      after = [ cfg.target ];
      partOf = [ cfg.target ];
      wantedBy = [ cfg.target ];
      restartTriggers = optional (
        cfg.extraConfig != null
      ) config.environment.etc."stasis/stasis.rune".source;

      serviceConfig = {
        Type = "simple";
        ExecStart = "${getExe cfg.package} ${escapeShellArgs cfg.extraArgs}";
        Restart = "on-failure";
      };
    };

    environment.etc."stasis/stasis.rune" = mkIf (cfg.extraConfig != null) {
      text = cfg.extraConfig;
    };
  };
}
