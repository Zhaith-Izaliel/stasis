use std::sync::Arc;
use eyre::Result;
use futures_util::stream::StreamExt;
use mpris::{PlayerFinder, PlaybackStatus};
use tokio::task;
use zbus::{Connection, MatchRule, MessageStream, fdo::ObjectManagerProxy};
use zvariant::{OwnedObjectPath, OwnedValue};
use zbus_names::OwnedInterfaceName;
use std::collections::HashMap;

use crate::core::manager::{
    helpers::{decr_active_inhibitor, incr_active_inhibitor},
    Manager,
};

const IGNORED_PLAYERS: &[&str] = &[
    "KDE Connect", "kdeconnect", "Chromecast", "chromecast",
    "Spotify Connect", "spotifyd", "vlc-http", "plexamp", "bluez",
];

lazy_static::lazy_static! {
    static ref AUDIO_MANAGER: Arc<tokio::sync::Mutex<AudioStreamManager>> =
        Arc::new(tokio::sync::Mutex::new(AudioStreamManager::new()));
}

pub async fn spawn_media_monitor_dbus(manager: Arc<tokio::sync::Mutex<Manager>>) -> Result<()> {
    let manager_clone = manager.clone();
    task::spawn(async move {
        let conn = match Connection::session().await {
            Ok(c) => c,
            Err(e) => {
                crate::log::log_error_message(&format!("Failed to connect to D-Bus: {}", e));
                return;
            }
        };

        // Spawn audio monitor
        spawn_audio_monitor(conn.clone(), AUDIO_MANAGER.clone()).await;

        // MPRIS signal stream
        let rule = MatchRule::builder()
            .msg_type(zbus::message::Type::Signal)
            .interface("org.freedesktop.DBus.Properties")
            .unwrap()
            .member("PropertiesChanged")
            .unwrap()
            .path_namespace("/org/mpris/MediaPlayer2")
            .unwrap()
            .build();

        let mut stream = match MessageStream::for_match_rule(rule, &conn, None).await {
            Ok(s) => s,
            Err(e) => {
                crate::log::log_error_message(&format!("Failed to create message stream: {}", e));
                return;
            }
        };

        // Create a watch channel to listen to audio stream changes
        let mut audio_rx = AUDIO_MANAGER.lock().await.subscribe();
        drop(AUDIO_MANAGER.lock().await);

        loop {
            tokio::select! {
                Some(_msg) = stream.next() => {
                    handle_media_check(&manager_clone).await;
                }
                Ok(Some(_)) = audio_rx.changed() => {
                    handle_media_check(&manager_clone).await;
                }
            }
        }
    });

    Ok(())
}

// Consolidated check function
async fn handle_media_check(manager: &Arc<tokio::sync::Mutex<Manager>>) {
    let (ignore_remote_media, media_blacklist) = {
        let mgr = manager.lock().await;
        let ignore = mgr.state.cfg.as_ref().map(|c| c.ignore_remote_media).unwrap_or(false);
        let blacklist = mgr.state.cfg.as_ref().map(|c| c.media_blacklist.clone()).unwrap_or_default();
        (ignore, blacklist)
    };

    let audio_mgr = AUDIO_MANAGER.lock().await;
    let any_playing = check_media_playing(ignore_remote_media, &media_blacklist, &audio_mgr);
    drop(audio_mgr);

    let mut mgr = manager.lock().await;
    if any_playing && !mgr.state.media_playing {
        incr_active_inhibitor(&mut mgr).await;
        mgr.state.media_playing = true;
        mgr.state.media_blocking = true;
    } else if !any_playing && mgr.state.media_playing {
        decr_active_inhibitor(&mut mgr).await;
        mgr.state.media_playing = false;
        mgr.state.media_blocking = false;
    }
}

pub fn check_media_playing(ignore_remote_media: bool, media_blacklist: &[String], audio_mgr: &AudioStreamManager) -> bool {
    let any_mpris_playing = match PlayerFinder::new() {
        Ok(finder) => match finder.find_all() {
            Ok(players) => players.iter().any(|player| {
                let is_playing = player.get_playback_status()
                    .map(|s| s == PlaybackStatus::Playing)
                    .unwrap_or(false);

                if !is_playing {
                    return false;
                }

                let identity = player.identity().to_lowercase();
                let bus_name = player.bus_name().to_string().to_lowercase();
                let blacklist_lower: Vec<String> = media_blacklist.iter().map(|b| b.to_lowercase()).collect();

                if blacklist_lower.iter().any(|b| identity.contains(b) || bus_name.contains(b)) {
                    return false;
                }

                if ignore_remote_media {
                    let is_remote = IGNORED_PLAYERS.iter().any(|s| {
                        let s_lower = s.to_lowercase();
                        identity.contains(&s_lower) || bus_name.contains(&s_lower)
                    });
                    !is_remote
                } else {
                    true
                }
            }),
            Err(e) => {
                crate::log::log_error_message(&format!("Failed to enumerate MPRIS players: {}", e));
                false
            }
        },
        Err(e) => {
            crate::log::log_error_message(&format!("Failed to initialize PlayerFinder: {}", e));
            false
        }
    };

    if !any_mpris_playing {
        return false;
    }

    if ignore_remote_media {
        audio_mgr.has_active_streams()
    } else {
        true
    }
}

// Async wrapper
pub async fn check_media_playing_async(ignore_remote_media: bool, media_blacklist: &[String]) -> bool {
    let audio_mgr = AUDIO_MANAGER.lock().await;
    check_media_playing(ignore_remote_media, media_blacklist, &audio_mgr)
}

// Audio stream manager with watch channel
pub struct AudioStreamManager {
    has_streams: bool,
    tx: Option<tokio::sync::watch::Sender<bool>>,
}

impl AudioStreamManager {
    fn new() -> Self {
        let (tx, _) = tokio::sync::watch::channel(false);
        Self { has_streams: false, tx: Some(tx) }
    }

    pub fn has_active_streams(&self) -> bool {
        self.has_streams
    }

    pub fn subscribe(&self) -> tokio::sync::watch::Receiver<bool> {
        self.tx.as_ref().unwrap().subscribe()
    }

    fn set_streams(&mut self, has_streams: bool) {
        if self.has_streams != has_streams {
            self.has_streams = has_streams;
            if let Some(tx) = &self.tx {
                let _ = tx.send(has_streams);
            }
        }
    }
}

// Spawn audio monitors
async fn spawn_audio_monitor(conn: Connection, manager: Arc<tokio::sync::Mutex<AudioStreamManager>>) {
    task::spawn(async move {
        crate::log::log_message("Starting audio stream monitor...");

        match monitor_pipewire_streams(conn.clone(), manager.clone()).await {
            Ok(_) => crate::log::log_message("PipeWire audio monitor started successfully"),
            Err(e) => {
                crate::log::log_message(&format!("PipeWire monitor failed ({}), trying PulseAudio...", e));
                if let Err(e) = monitor_pulseaudio_streams(conn, manager).await {
                    crate::log::log_error_message(&format!("Failed to start audio monitor: {}", e));
                }
            }
        }
    });
}

// Monitor PipeWire
async fn monitor_pipewire_streams(conn: Connection, manager: Arc<tokio::sync::Mutex<AudioStreamManager>>) -> Result<()> {
    crate::log::log_message("Attempting to connect to PipeWire D-Bus...");

    let destinations = vec!["org.pipewire.Daemon", "org.pipewire.Core", "org.PipeWire"];
    let mut proxy = None;

    for dest in destinations {
        for path in [&"/org/pipewire", &"/org/pipewire/core", &"/org/pipewire/daemon"] {
            if let Ok(p) = ObjectManagerProxy::builder(&conn).destination(dest)?.path(*path)?.build().await {
                crate::log::log_message(&format!("Connected to PipeWire at {} {}", dest, path));
                proxy = Some(p);
                break;
            }
        }
        if proxy.is_some() { break; }
    }

    let proxy = proxy.ok_or_else(|| eyre::eyre!("Could not connect to PipeWire D-Bus"))?;
    let objects = proxy.get_managed_objects().await?;
    let initial_streams = count_audio_streams_pipewire(&objects);

    {
        let mut mgr = manager.lock().await;
        mgr.set_streams(initial_streams > 0);
    }

    let mut added = proxy.receive_interfaces_added().await?;
    let mut removed = proxy.receive_interfaces_removed().await?;

    loop {
        tokio::select! {
            Some(_) = added.next() => {
                let objs = proxy.get_managed_objects().await?;
                let count = count_audio_streams_pipewire(&objs);
                let mut mgr = manager.lock().await;
                mgr.set_streams(count > 0);
            }
            Some(_) = removed.next() => {
                let objs = proxy.get_managed_objects().await?;
                let count = count_audio_streams_pipewire(&objs);
                let mut mgr = manager.lock().await;
                mgr.set_streams(count > 0);
            }
        }
    }
}

// Monitor PulseAudio
async fn monitor_pulseaudio_streams(conn: Connection, manager: Arc<tokio::sync::Mutex<AudioStreamManager>>) -> Result<()> {
    crate::log::log_message("Attempting to connect to PulseAudio D-Bus...");

    let destinations = vec!["org.pulseaudio.Server", "org.PulseAudio1", "org.PulseAudio"];
    let mut proxy = None;

    for dest in destinations {
        for path in [&"/org/pulseaudio/core1", &"/org/pulseaudio", &"/org/pulseaudio/core"] {
            if let Ok(p) = ObjectManagerProxy::builder(&conn).destination(dest)?.path(*path)?.build().await {
                crate::log::log_message(&format!("Connected to PulseAudio at {} {}", dest, path));
                proxy = Some(p);
                break;
            }
        }
        if proxy.is_some() { break; }
    }

    let proxy = proxy.ok_or_else(|| eyre::eyre!("Could not connect to PulseAudio D-Bus"))?;
    let objects = proxy.get_managed_objects().await?;
    let initial_streams = count_audio_streams_pulse(&objects);

    {
        let mut mgr = manager.lock().await;
        mgr.set_streams(initial_streams > 0);
    }

    let mut added = proxy.receive_interfaces_added().await?;
    let mut removed = proxy.receive_interfaces_removed().await?;

    loop {
        tokio::select! {
            Some(_) = added.next() => {
                let objs = proxy.get_managed_objects().await?;
                let count = count_audio_streams_pulse(&objs);
                let mut mgr = manager.lock().await;
                mgr.set_streams(count > 0);
            }
            Some(_) = removed.next() => {
                let objs = proxy.get_managed_objects().await?;
                let count = count_audio_streams_pulse(&objs);
                let mut mgr = manager.lock().await;
                mgr.set_streams(count > 0);
            }
        }
    }
}

fn count_audio_streams_pipewire(objects: &HashMap<OwnedObjectPath, HashMap<OwnedInterfaceName, HashMap<String, OwnedValue>>>) -> usize {
    objects.iter().filter(|(path, interfaces)| {
        let path_str = path.as_str().to_lowercase();
        let path_matches = path_str.contains("/stream") || path_str.contains("stream");
        let iface_matches = interfaces.keys().any(|iface| iface.as_str().to_lowercase().contains("stream"));
        path_matches && iface_matches
    }).count()
}

fn count_audio_streams_pulse(objects: &HashMap<OwnedObjectPath, HashMap<OwnedInterfaceName, HashMap<String, OwnedValue>>>) -> usize {
    objects.iter().filter(|(path, interfaces)| {
        let path_str = path.as_str().to_lowercase();
        let path_ok = path_str.contains("/stream") || path_str.contains("stream") || path_str.contains("playback") || path_str.contains("record");
        let iface_ok = interfaces.keys().any(|iface| {
            let iface_str = iface.as_str().to_lowercase();
            iface_str.contains("pulseaudio") || iface_str.contains("core1") || iface_str.contains("stream") || iface_str.contains("playbackstream") || iface_str.contains("recordstream")
        });
        path_ok && iface_ok
    }).count()
}
